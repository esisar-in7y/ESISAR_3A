#include <stdio.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <wait.h>
#include <string.h>

#define NOMBRE_OUVRIER 59
#define PLACES_ASCENSEUR 10
#define NOM "tp6.c"
#define ID 1
#define NB_SEM 1
#define TAILLE_SHM 500//sizeof(pid_t) * PLACES_ASCENSEUR

#define SLEEP 1
#define NC  "\x1B[0m"
#define RED  "\x1B[31m"
#define GRN  "\x1B[32m"
#define YEL  "\x1B[33m"
#define BLU  "\x1B[34m"

int cree_segment(char* nom, size_t taille, int id);

int main(){
  pid_t pid;

  /*Initialisation des variables utilisées pour le shm*/
  char* mem;
  int shmid;

  /*Initialisation des variables utilisées pour le sémaphore*/
  struct sembuf sem_ascenseur;  //Needed for semop()
  int semid;

  /*Creation d'une cle*/
  key_t cle = ftok(NOM, ID);
  if (cle < 0){
    perror("erreur ftok");
    exit(1);
  }
  
  /*Creation d'un semaphore*/
  semid = semget(cle, NB_SEM, IPC_CREAT | 0666);
  if (semid < 0){
    perror("erreur semget");
    exit(1);
  }
  
  /*Initialisation de la structure sembuf*/
  sem_ascenseur.sem_num = semid;
  sem_ascenseur.sem_op = -1;
  sem_ascenseur.sem_flg = 0;
  /*Initialisation du semaphore à 1*/
  if (semctl(semid, 0, SETVAL, /*arg*/PLACES_ASCENSEUR) < 0){
    perror("erreur semctl");
    exit(1);
  }
  /*Création d'un shm*/
  shmid = cree_segment(NOM, TAILLE_SHM, ID);
  mem = shmat(shmid, NULL, 0);  //Attachement du shm à mem
  pid_t *shm_tab = (pid_t *) mem;
  int i,j;
  for(i=0; i<PLACES_ASCENSEUR; i++) shm_tab[i]=0;
  i=0;
  while ( i<NOMBRE_OUVRIER && (pid = fork())!=0 ) i++; //Création de N fils
    
	if ( pid == 0){ //Si FILS
		sem_ascenseur.sem_flg = SEM_UNDO; // Trop bien l'invité restore tout seul sa place
		semop(semid, &sem_ascenseur, 1);  //Fait -1 au sémaphore si disponible
		printf(RED"Je monte"NC":"YEL"%d\n"NC, getpid());
		j=0;
		while(j<PLACES_ASCENSEUR && shm_tab[j]!=0) j++;
		shm_tab[j] = getpid();

		pause();  //Attend un signal
	}
	else if (pid > 0){  //1er père uniquement
		i=0;  //Compte le nombre de fils
		while(i<NOMBRE_OUVRIER){

			// /*  //Partie ancienne, ne fonctionne pas si on a un nombre impair
			sem_ascenseur.sem_op = 0;
			semop(semid, &sem_ascenseur, 1);  //Attend que le sémaphore soit pris par un processus
			sleep(SLEEP);
			i+=PLACES_ASCENSEUR; */
			
			// Dès qu'un ouvrier monte dans l'ascenseur
			while ( semctl(semid, 0, GETVAL) == PLACES_ASCENSEUR ) usleep(500);
			// On attends au cas où il y en a d'autre
			sleep(SLEEP);

			
			printf(GRN"Sont montés"NC":"YEL"[%d]"NC,shm_tab[0]);
			for(j=1; j<PLACES_ASCENSEUR && shm_tab[j]!=0; j++) printf(","YEL"[%d]"NC,shm_tab[j]);
			printf("\n j=%d\n",j);
			int max = j;
			
			i+=max;

			/*Envoie de SIGUSR1 aux deux fils qui sont montés*/
			for(j=0; j<max; j++) kill(shm_tab[j], SIGUSR1);

			/*Libération du semaphore*/
			printf(BLU"C'est libre !\n"NC);
			for(j=0; j<max; j++) shm_tab[j]=0;
			// Plus besoin pcq les fils ont mis SEM_UNDO
			// sem_ascenseur.sem_op = PLACES_ASCENSEUR;
			// semop(semid, &sem_ascenseur, 1);
		}
		shmdt(mem);
	  }
	
  return 0;
}


int cree_segment(char* nom, size_t taille, int id){
	key_t cle = ftok(nom, id);
	if(cle<0){
		perror("erreur de ftok");
		exit(1);
	}
	int shmid = shmget(cle, taille, IPC_CREAT | 0666) ;
	if(shmid<0){
		perror("erreur de shmget");
		exit(1);
	}
	return shmid;
}
